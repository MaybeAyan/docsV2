import{_ as r,o as n,c as d,a,t as s,b as e,d as i}from"./app-0b91c857.js";const h={},l=e('<h2 id="前端开发工程化" tabindex="-1"><a class="header-anchor" href="#前端开发工程化" aria-hidden="true">#</a> 前端开发工程化</h2><p>模块化（JS 的模块化、CSS 的模块化、资源的模块化）<br> 组件化（复用现有的 ui 结构、样式、行为）<br> 规范化（目录结构的划分、编码规范化、接口规范化、文档规范化、Git 分支管理）<br> 自动化（自动化构建、自动部署、自动化测试）</p><h2 id="webpack" tabindex="-1"><a class="header-anchor" href="#webpack" aria-hidden="true">#</a> webpack</h2><p>webpack 是前端项目工程化的具体解决方案</p><p>主要功能：提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JS 的兼容性、性能优化等强大功能</p><h3 id="loader-加载器" tabindex="-1"><a class="header-anchor" href="#loader-加载器" aria-hidden="true">#</a> loader 加载器</h3><p>协助 webpack 打包处理待定的文件模块</p><h3 id="base64-图片解码" tabindex="-1"><a class="header-anchor" href="#base64-图片解码" aria-hidden="true">#</a> base64 图片解码</h3><p>可以防止不必要的请求，性能优化的手段</p><p>缺点：解码后体积变大</p><h3 id="source-map" tabindex="-1"><a class="header-anchor" href="#source-map" aria-hidden="true">#</a> source Map</h3><p>储存位置信息，开发调试阶段查错比较方便</p><p><code>devtool：eval-source-map</code></p><p>发布阶段不定位错误代码位置，出于安全考虑</p><p>实际发布阶段 devtool 的值设置为 <code>nosources-source-map</code></p><h2 id="vue-js" tabindex="-1"><a class="header-anchor" href="#vue-js" aria-hidden="true">#</a> Vue.js</h2><p>vue 是一套用于构建用户界面的前端框架，框架是一套现成的解决方案，程序员只能遵守框架的规范，编写自己的业务功能</p><ul><li><p>Vue 的指令、组件（对 UI 结构的复用）、路由、Vuex、Vue 组件库</p></li><li><p>学习框架的规范语法</p></li></ul><h2 id="vue-的特性" tabindex="-1"><a class="header-anchor" href="#vue-的特性" aria-hidden="true">#</a> Vue 的特性</h2><h3 id="_1-数据驱动视图" tabindex="-1"><a class="header-anchor" href="#_1-数据驱动视图" aria-hidden="true">#</a> 1.数据驱动视图</h3><ul><li><p>数据的变化会驱动视图自动更新</p></li><li><p>好处：程序员只需要把数据维护好，那么页面结构会被 vue 自动渲染出来</p></li></ul><h3 id="_2-双向数据绑定" tabindex="-1"><a class="header-anchor" href="#_2-双向数据绑定" aria-hidden="true">#</a> 2.双向数据绑定</h3><p>在网页中，form 表单负责采集数据，Ajax 负责提交数据</p><ul><li><p>js 的数据变化，会被自动渲染到页面上</p></li><li><p>页面上表单采集的数据发生变化的时候，会被 vue 监听到，自动更新到 js 数据中</p></li></ul><h2 id="mvvm" tabindex="-1"><a class="header-anchor" href="#mvvm" aria-hidden="true">#</a> MVVM</h2><p>MVVM 是 vue 实现数据驱动视图和双向数据绑定的核心原理。MVVM 指的是 Model、View 和 ViewModel</p><p>Model 指的是页面渲染时所依赖的数据源</p><p>View 指的是页面所渲染的 DOM 结构</p><p>ViewModel 指的是 vue 的实例，他是 MVVM 的核心</p><h2 id="vue-的基础用法" tabindex="-1"><a class="header-anchor" href="#vue-的基础用法" aria-hidden="true">#</a> Vue 的基础用法</h2><p>指令是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构</p><p>1、内容渲染</p><p>2、属性绑定</p><p>3、事件绑定</p><p>4、双向绑定</p><p>5、条件渲染</p><p>6、列表渲染</p><h3 id="内容渲染" tabindex="-1"><a class="header-anchor" href="#内容渲染" aria-hidden="true">#</a> 内容渲染</h3>',38),p=a("h4",{id:"v-txet",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#v-txet","aria-hidden":"true"},"#"),i(" v-txet")],-1),t=a("p",null,"1、缺点：会覆盖元素内部原有的内容",-1),o=a("p",null,"3、v-text 和插值表达式只能渲染纯文本内容",-1),c=a("li",null,[a("h4",{id:"v-html",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#v-html","aria-hidden":"true"},"#"),i(" v-html")]),a("p",null,"把带有标签的字符串，渲染成 HTML 内容")],-1),u=e(`<h3 id="属性绑定" tabindex="-1"><a class="header-anchor" href="#属性绑定" aria-hidden="true">#</a> 属性绑定</h3><p>注意：插值表达式只能用在内容节点中，不能用于属性节点上</p><ul><li><p>v-bind： 为元素的属性动态绑定数值</p></li><li><p>简写是 <code>:</code></p></li></ul><h3 id="事件绑定" tabindex="-1"><a class="header-anchor" href="#事件绑定" aria-hidden="true">#</a> 事件绑定</h3><ul><li><p><code>v-on:</code> 绑定事件，同时可以加（）传递参数</p></li><li><p>简写是 <code>@</code></p></li><li><p><code>$event</code> 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个$event</p></li><li><p>事件修饰符 .stop 阻止冒泡 .prevent 阻止标签默认行为</p></li></ul><h3 id="双向绑定指令" tabindex="-1"><a class="header-anchor" href="#双向绑定指令" aria-hidden="true">#</a> 双向绑定指令</h3><ul><li><h4 id="v-model-指令" tabindex="-1"><a class="header-anchor" href="#v-model-指令" aria-hidden="true">#</a> v-model 指令</h4></li><li><h4 id="v-model-修饰符" tabindex="-1"><a class="header-anchor" href="#v-model-修饰符" aria-hidden="true">#</a> v-model 修饰符</h4><ul><li>.trim 去除表单字符串里的空格</li><li>.number 转换为数字类型</li><li>.lazy 取消实时同步 输入完毕失去焦点后再同步</li></ul></li></ul><h3 id="条件渲染指令" tabindex="-1"><a class="header-anchor" href="#条件渲染指令" aria-hidden="true">#</a> 条件渲染指令</h3><ul><li>v - if 动态创建或删除元素，实现元素的显示和隐藏 <ul><li>如果刚进入页面的时候，某些元素默认不需要被显示，而且后期这个元素也可能不需要被展示出来，此时 v - if 性能更好</li></ul></li><li>v - show 动态为元素添加或移除样式<code>display：none;</code><ul><li>如果要频繁的切换元素的显示状态，用 v - show 性能更好</li></ul></li></ul><h3 id="列表渲染指令" tabindex="-1"><a class="header-anchor" href="#列表渲染指令" aria-hidden="true">#</a> 列表渲染指令</h3><p>v-for 指令，用来辅助开发者基于一个数组来循环渲染一个列表结构</p><h3 id="过滤器-vue2" tabindex="-1"><a class="header-anchor" href="#过滤器-vue2" aria-hidden="true">#</a> 过滤器（vue2）</h3><p>fliters 常用于文本的格式化 可以用在插值表达式和 V-bind 属性绑定</p><p>用管道符 <code>|</code> 表示</p><ul><li><h4 id="私有过滤器-fliters" tabindex="-1"><a class="header-anchor" href="#私有过滤器-fliters" aria-hidden="true">#</a> 私有过滤器 fliters</h4></li><li><h4 id="全局过滤器-fliter" tabindex="-1"><a class="header-anchor" href="#全局过滤器-fliter" aria-hidden="true">#</a> 全局过滤器 fliter</h4><p>全局过滤器 Vue.filter () 方法接受两个参数：</p><p>1、第一个参数是全局过滤器的名字</p><p>2、第二个参数是全局过滤器的处理函数</p></li></ul><h4 id="过滤器需要注意的地方" tabindex="-1"><a class="header-anchor" href="#过滤器需要注意的地方" aria-hidden="true">#</a> 过滤器需要注意的地方</h4><ol><li>要定义到 filters 节点下，本质上是一个函数</li><li>在过滤器函数中， 一定要有返回值 return</li><li>在过滤器的形参中，可以获取到管道符前面待处理的数值</li><li>如果全局过滤器和私有过滤器名字一致，此时按照就近原则，调用的是私有过滤器</li></ol><h3 id="侦听器-watch" tabindex="-1"><a class="header-anchor" href="#侦听器-watch" aria-hidden="true">#</a> 侦听器 watch</h3><p>侦听器的作用是监听数据的变化，从而针对数据的变化做特定的操作</p><p>watch（ newVal，oldVal ）{ }</p><p>通常用来配合 Ajax 发送请求判断表单数据是否重复 （用户名是否被占用）</p><ol><li><p>方法格式的侦听器</p><ul><li>缺点 1：无法在刚进入页面的时候，自动触发！！</li><li>缺点 2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器</li></ul></li><li><p>对象格式的侦听器</p><ul><li>好处 1：可以通过 immediate 选项，让侦听器自动触发</li><li>好处 2：可以通过 deep 属性，让侦听器实现深度侦听（deep 属性默认关闭）</li><li>监听子元素的变化，命名要加单引号 &#39; &#39;</li></ul></li></ol><h3 id="计算属性" tabindex="-1"><a class="header-anchor" href="#计算属性" aria-hidden="true">#</a> 计算属性</h3><p>特点：</p><ol><li>定义的时候，要被定义成方法</li><li>在使用计算属性的时候，当普通的属性使用即可</li></ol><p>好处:</p><ol><li>实现了代码复用</li><li>只要计算属性中依赖的数据源发生变化，计算属性会自动重新求职</li></ol><h2 id="axios" tabindex="-1"><a class="header-anchor" href="#axios" aria-hidden="true">#</a> axios</h2><p>axios 是一个专注于网络请求的库</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> res <span class="token operator">=</span> axios（<span class="token punctuation">{</span>
    <span class="token literal-property property">method</span><span class="token operator">:</span><span class="token string">&#39;get&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">url</span><span class="token operator">:</span><span class="token string">&quot;http:/www.baidu.com&quot;</span>
<span class="token punctuation">}</span>）
result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">books</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>books<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>axios 在请求到数据之后，在真正的数据之外套了一层壳<br> axios 的返回值是一个 promise，因此可以使用 async 和 await 修饰<br> axios 也可以用 get() post() 等 ajax 的方法</p><h2 id="vue-cli" tabindex="-1"><a class="header-anchor" href="#vue-cli" aria-hidden="true">#</a> vue-cli</h2><p>vue-cli 是 vue.js 开发的标准工具，简化了基于 webpack 创建工程化的步骤</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>vue create 项目名称
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="vue-项目中-src-目录的构成" tabindex="-1"><a class="header-anchor" href="#vue-项目中-src-目录的构成" aria-hidden="true">#</a> vue 项目中 src 目录的构成</h3><p>assets 文件夹：存放项目中用到的静态资源文件，例如css样式表、图片资源等 components 文件夹：程序员封装的，可复用的组件，都要放到 components 目录下 main.js 是项目的入口文件，整个项目的运行，要先执行 main.js</p><h3 id="vue-项目的运行流程" tabindex="-1"><a class="header-anchor" href="#vue-项目的运行流程" aria-hidden="true">#</a> vue 项目的运行流程</h3><p>在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中</p><ol><li>App.vue 用来编写待渲染的模块结构</li><li>index.html 中需要预留一个 el 区域</li><li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li></ol><h3 id="vue-中的组件化开发" tabindex="-1"><a class="header-anchor" href="#vue-中的组件化开发" aria-hidden="true">#</a> vue 中的组件化开发</h3><ul><li><p>template 组件的模块结构</p></li><li><p>script 组建的 JavaScript 行为</p></li><li><p>style 组件的样式</p></li></ul><h3 id="vue-组件中的父子关系" tabindex="-1"><a class="header-anchor" href="#vue-组件中的父子关系" aria-hidden="true">#</a> Vue 组件中的父子关系</h3><h4 id="使用组件的三个步骤" tabindex="-1"><a class="header-anchor" href="#使用组件的三个步骤" aria-hidden="true">#</a> 使用组件的三个步骤</h4><p>1.使用 import 语法导入组件</p><p>2.使用 components 节点注册组件</p><p>3.以标签形式使用刚才注册的组件</p><h4 id="通过-components-注册的是私有子组件" tabindex="-1"><a class="header-anchor" href="#通过-components-注册的是私有子组件" aria-hidden="true">#</a> 通过 components 注册的是私有子组件</h4><h4 id="注册全局组件" tabindex="-1"><a class="header-anchor" href="#注册全局组件" aria-hidden="true">#</a> 注册全局组件</h4><p>在 vue 项目的 main.js 入口文件中，通过 Vue.components() 方法，可以注册全局组件</p><h4 id="组件的-props-属性" tabindex="-1"><a class="header-anchor" href="#组件的-props-属性" aria-hidden="true">#</a> 组件的 props 属性</h4><p>props 是组件的自定义属性，在封装通用组件的时候，合理地使用 props 可以极大地提高组件的复用性</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>props：<span class="token punctuation">[</span><span class="token string">&#39;init&#39;</span><span class="token punctuation">]</span>
<span class="token comment">// 自定义属性的名字，是封装者自定义的，名称合法即可</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>props 中的数据，可以直接在模板结构中被使用</p><p>props 是只读的，vue 规定：组件中封装的自定义属性是只读的，程序员不能直接修改 props 的数值，否则会直接报错</p><h5 id="props-的-default-默认值" tabindex="-1"><a class="header-anchor" href="#props-的-default-默认值" aria-hidden="true">#</a> props 的 default 默认值</h5><p>在声明自定义属性的时候，通过 default 声明默认值</p><h5 id="props-的-type-值类型" tabindex="-1"><a class="header-anchor" href="#props-的-type-值类型" aria-hidden="true">#</a> props 的 type 值类型</h5><p>在声明自定义属性的时候，通过 type 来定义属性的值类型</p><h5 id="props-的-required-必填项" tabindex="-1"><a class="header-anchor" href="#props-的-required-必填项" aria-hidden="true">#</a> props 的 required 必填项</h5><h3 id="vue-组件之间的样式冲突" tabindex="-1"><a class="header-anchor" href="#vue-组件之间的样式冲突" aria-hidden="true">#</a> vue 组件之间的样式冲突</h3><p>默认的 .vue 样式是全局生效的 因此需要添加 scoped 到样式属性中</p><p>/deep/ 可以从父组件中修改子组件的样式</p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期" aria-hidden="true">#</a> 生命周期</h2><h2 id="组件之间的传值-数据共享" tabindex="-1"><a class="header-anchor" href="#组件之间的传值-数据共享" aria-hidden="true">#</a> 组件之间的传值（数据共享）</h2><h4 id="父子组件" tabindex="-1"><a class="header-anchor" href="#父子组件" aria-hidden="true">#</a> 父子组件</h4><ol><li><h5 id="父向子传值-使用-props" tabindex="-1"><a class="header-anchor" href="#父向子传值-使用-props" aria-hidden="true">#</a> 父向子传值，使用 props</h5></li><li><h5 id="子向父传值-使用自定义事件传递" tabindex="-1"><a class="header-anchor" href="#子向父传值-使用自定义事件传递" aria-hidden="true">#</a> 子向父传值，使用自定义事件传递</h5></li></ol><h4 id="兄弟组件之间的传值" tabindex="-1"><a class="header-anchor" href="#兄弟组件之间的传值" aria-hidden="true">#</a> 兄弟组件之间的传值</h4><ol><li>EventBus</li></ol><h2 id="动态组件" tabindex="-1"><a class="header-anchor" href="#动态组件" aria-hidden="true">#</a> 动态组件</h2><p>component 标签是 vue 内置的，作用是：组件的占位符<br> keep-alive 标签 可以把内部的组件进行缓存，而不是销毁组件</p><h2 id="插槽" tabindex="-1"><a class="header-anchor" href="#插槽" aria-hidden="true">#</a> 插槽</h2><p>插槽是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽。</p><h2 id="路由" tabindex="-1"><a class="header-anchor" href="#路由" aria-hidden="true">#</a> 路由</h2><p>路由 router 就是对应关系</p><h4 id="前端路由" tabindex="-1"><a class="header-anchor" href="#前端路由" aria-hidden="true">#</a> 前端路由</h4><p>Hash 地址与组件之间的对应关系</p><h4 id="前端路由工作方式" tabindex="-1"><a class="header-anchor" href="#前端路由工作方式" aria-hidden="true">#</a> 前端路由工作方式</h4><ol><li>用户点击了页面上的路由连接</li><li>导致了 URL 地址栏的 Hash 值发生变化</li><li>前端路由监听到了 Hash 地址的变化</li><li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中</li></ol><h4 id="路由重定向" tabindex="-1"><a class="header-anchor" href="#路由重定向" aria-hidden="true">#</a> 路由重定向</h4><p>用户在访问地址 A 的时候，强制用户跳转到 C 地址，从而展示特定的组件页面，通过路由规则的 redircet 属性，指定一个新的路由地址，可以很方便地设置路由的重定向</p><h4 id="嵌套路由" tabindex="-1"><a class="header-anchor" href="#嵌套路由" aria-hidden="true">#</a> 嵌套路由</h4><h5 id="子级路由" tabindex="-1"><a class="header-anchor" href="#子级路由" aria-hidden="true">#</a> 子级路由</h5><ol><li>默认子路由</li><li>路由规则</li><li>路由重定向</li></ol><h4 id="动态路由" tabindex="-1"><a class="header-anchor" href="#动态路由" aria-hidden="true">#</a> 动态路由</h4><p>把 hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性</p><p>在 vue-router 中使用英文的冒号 ：来定义路由的参数项。</p><h4 id="路由导航" tabindex="-1"><a class="header-anchor" href="#路由导航" aria-hidden="true">#</a> 路由导航</h4><h6 id="声明式导航-点击链接" tabindex="-1"><a class="header-anchor" href="#声明式导航-点击链接" aria-hidden="true">#</a> 声明式导航（点击链接）</h6><ul><li>普通网页中点击 a 标签</li><li>vue 项目中点击 <code>&lt;router-link&gt;</code> 标签</li></ul><h6 id="编程式导航-调用-api" tabindex="-1"><a class="header-anchor" href="#编程式导航-调用-api" aria-hidden="true">#</a> 编程式导航（调用 API）</h6><ul><li>普通网页调用 location.href 跳转到新页面的方式</li><li>vue 项目中的一些 API</li></ul>`,91);function v(b,f){return n(),d("div",null,[l,a("ul",null,[a("li",null,[p,t,a("p",null,"2、插值表达式 "+s()+" 在实际开发中用的更多",1),o]),c]),u])}const m=r(h,[["render",v],["__file","VueNote.html.vue"]]);export{m as default};
