import{_ as i,o as l,c as a,a as e}from"./app-d5c63569.js";const r={},h=e('<h1 id="内存管理" tabindex="-1"><a class="header-anchor" href="#内存管理" aria-hidden="true">#</a> 内存管理</h1><h1 id="垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#垃圾回收机制" aria-hidden="true">#</a> 垃圾回收机制</h1><ol><li>Gc 算法（Mark-Sweep） <ol><li>标记清除的核心思路是可达性</li><li>设置根对象，垃圾回收器会定期从这个根开始，找所有从根开始有引用到的对象，对于那些没有引用到的对象，就认为是不可用的对象；</li><li>有效解决循环引用的问题；</li></ol></li><li>标记整理 （Mark-Compact） <ol><li>回收期间同时会将保留的存储对象搬运汇集到连续的内存空间，从而整合空闲空间，避免内存的碎片化；</li></ol></li><li>分代收集 <ol><li>对象被分成两组 ：新代和旧代</li><li>许多对象出现，完成它们的工作并很快死去，它们可以很快地被清理</li><li>长期存活的对象会变得老旧，而且被检查的频次也会减少</li></ol></li><li>增量收集 <ol><li>如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟</li><li>所以引擎试图将垃圾收集工作分成几部分来做，然后将这几部分逐一进行处理，这样会有许多微小的延迟而不是一个大的延迟</li></ol></li><li>闲时收集 <ol><li>垃圾收集器只会在 cpu 空闲时尝试运行，以减少可能对代码执行的影响</li></ol></li></ol><h1 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h1><ul><li>闭包：词法闭包 函数闭包</li><li>是在支持头等函数的编程语言中，实现词法绑定的一种技术</li><li>闭包在实现上是一个结构体，存储了一个函数和一个关联的环境（相当于一个符号查找表）</li><li>闭包和函数的最大区别在于，当捕捉闭包的时候，他的自由变量会在捕捉时被确定，这样即使脱离了捕捉时的上下文，他也能够照常运行；</li></ul><h3 id="mdn-的定义" tabindex="-1"><a class="header-anchor" href="#mdn-的定义" aria-hidden="true">#</a> MDN 的定义</h3><ul><li>一个函数对其周围状态的引用捆绑在一起，这样的组合就是闭包</li><li>闭包让你可以在一个内层函数中访问到外层函数的作用域</li><li>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来</li></ul><h3 id="内存泄漏" tabindex="-1"><a class="header-anchor" href="#内存泄漏" aria-hidden="true">#</a> 内存泄漏</h3><p>对于那些我们永远不会再使用的对象，GC 是不知道要进行释放对应的内存的，根据可达性仍会保留着，因此我们一般要手动释放（赋值 null ）</p><h3 id="v8-引擎的属性优化" tabindex="-1"><a class="header-anchor" href="#v8-引擎的属性优化" aria-hidden="true">#</a> V8 引擎的属性优化</h3><p>对于没使用到的属性浏览器 V8 会在闭包中剔除掉，做内存释放</p>',11),n=[h];function d(o,c){return l(),a("div",null,n)}const s=i(r,[["render",d],["__file","JS nacunguanliyubibao.html.vue"]]);export{s as default};
