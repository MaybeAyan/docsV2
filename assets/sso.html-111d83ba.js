import{_ as e,o as a,c as i,a as r}from"./app-d5c63569.js";const t={},l=r('<h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>近期公司后台系统需要重新迭代登录页<br> 之前一直是 cv 其他项目的代码<br> 在和后端配合的时候<br> 发现自己对单点登录的理解不深 所以记录学习一下</p><h2 id="单点登录" tabindex="-1"><a class="header-anchor" href="#单点登录" aria-hidden="true">#</a> 单点登录</h2><p>公司多个后台，采用统一登录方式，只需登录其中一个后台，就可以不必登录进入其他后台<br> 比如阿里的淘宝与天猫，登录了淘宝，天猫也会自动登录</p><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h2><ul><li>提升用户体验：只需登录一次就可以访问多个网站或者应用程序，减少不必要的频繁输入操作</li><li>提高安全性：用户的凭据只需在登录时输入一次，减少了凭据泄露的风险</li><li>简化管理：管理员只需管理一个身份验证系统，而不是多个应用程序的用户账户。</li></ul><h2 id="实现过程" tabindex="-1"><a class="header-anchor" href="#实现过程" aria-hidden="true">#</a> 实现过程</h2><ol><li>用户进入应用 ==&gt; 未登录 ==&gt; url 携带 referer 参数和 callback 参数跳转统一登录页面</li><li>统一登录页面 ==&gt; 用户输入账密 ==&gt; 接口获取凭据</li><li>接口凭据获取 token ==&gt; 用户进入 session 页面 ==&gt; 接口检验 token 合法性</li><li>校验通过 ==&gt; 跳回应用页面</li><li>用户登出 ==&gt; 本地清空登录状态 ==&gt; 服务端遍历发过凭据的所有产品（应用）==&gt; 调取对应api ==&gt; 完成退出</li></ol><p>补充：token 是在服务端产生的。如果前端使用用户名/密码向服务端请求认证，服务端认证成功，那么在服务端会返回 token 给前端。前端可以在每次请求的时候带上 token 证明自己的合法地位。如果这个 token 在服务端持久化（比如存入数据库），那它就是一个永久的身份令牌。</p><h2 id="bug-隐患" tabindex="-1"><a class="header-anchor" href="#bug-隐患" aria-hidden="true">#</a> Bug 隐患</h2><p>公司旧版本的 SSO 统一登录在登出后，并没有在服务端清空 token，这样会带来一个严重的问题。<br> 如果我在 SSO 没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>单点登录（SSO）的所有流程都介绍完了，原理大家都清楚了。总结一下单点登录要做的事情：</p><ul><li>单点登录（SSO系统）是保障各业务系统的用户资源的安全 。</li><li>各个业务系统获得的信息是，这个用户能不能访问我的资源。</li><li>单点登录，资源都在各个业务系统这边，不在SSO那一方。<br> 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。</li></ul>',14),h=[l];function n(d,o){return a(),i("div",null,h)}const c=e(t,[["render",n],["__file","sso.html.vue"]]);export{c as default};
